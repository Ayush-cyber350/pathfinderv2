{"version":3,"sources":["logo.svg","files/Node/Node.jsx","files/Algorithm/dijkstra.jsx","files/Pathfind.jsx","App.js","reportWebVitals.js","index.js"],"names":["Node","this","props","col","row","isStart","isFinish","onMouseDown","onMouseEnter","onMouseUp","isWall","extraClassName","id","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","START_ROW","START_COL","END_ROW","window","screen","height","END_COL","width","WALL_TOGGLE","Pathfind","state","getInitialGrid","setState","newGrid","getNewGrid","mouseIsPressed","getGridWall","getNewEnd","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","endNode","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","class","onClick","visualizeDijkstra","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","React","currentRow","createNode","slice","newNode","newNodeS","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.dd07f097.chunk.js","sourcesContent":["export default __webpack_public_path__ + \"static/media/logo.6ce24c58.svg\";","import React, {Component} from 'react';\r\nimport  '../Node.css';\r\nexport default class Node extends Component{\r\n    render(){\r\n        const {\r\n            col,\r\n            row,\r\n            isStart,\r\n            isFinish,\r\n            onMouseDown,\r\n            onMouseEnter,\r\n            onMouseUp,\r\n            isWall\r\n        }= this.props;\r\n        const extraClassName = isFinish\r\n      ? 'node-finish'\r\n      : isStart\r\n      ? 'node-start'\r\n      :isWall\r\n      ? 'node-wall'\r\n      : '';\r\n    \r\n        return(\r\n            <div id ={`node-${row}-${col}`} \r\n            className ={`node ${extraClassName}`}\r\n            onMouseDown={() => onMouseDown(row, col)}\r\n            onMouseEnter={()=>onMouseEnter(row,col)}\r\n            onMouseUp={() => onMouseUp(row, col)}\r\n            >\r\n            </div>\r\n        );\r\n    }\r\n}","export function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n      sortNodesByDistance(unvisitedNodes);\r\n      const closestNode = unvisitedNodes.shift();\r\n      if(closestNode.isWall)continue;\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n  \r\n  function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n  \r\n  function updateUnvisitedNeighbors(node, grid) {\r\n    const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      neighbor.distance = node.distance + 1;\r\n      neighbor.previousNode = node;\r\n    }\r\n  }\r\n  \r\n  function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n    if (row > 0) neighbors.push(grid[row - 1][col]);\r\n    if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n    if (col > 0) neighbors.push(grid[row][col - 1]);\r\n    if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n  }\r\n  \r\n  function getAllNodes(grid) {\r\n    const nodes = [];\r\n    for (const row of grid) {\r\n      for (const node of row) {\r\n        nodes.push(node);\r\n      }\r\n    }\r\n    return nodes;\r\n  }\r\n\r\n export function getNodesInShortestPathOrder(finishNode) {\r\n    const nodesInShortestPathOrder = [];\r\n    let currentNode = finishNode;\r\n    while (currentNode !== null) {\r\n      nodesInShortestPathOrder.unshift(currentNode);\r\n      currentNode = currentNode.previousNode;\r\n    }\r\n    return nodesInShortestPathOrder;\r\n  }","import React from \"react\";\r\nimport './Pathfind.css';\r\nimport Node from \"./Node/Node\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"./Algorithm/dijkstra.jsx\";\r\n\r\nlet START_ROW =2 ;\r\nlet START_COL= 2;\r\nlet END_ROW = (window.screen.height/56)-3;\r\nlet END_COL =(window.screen.width/40)-3;\r\nlet WALL_TOGGLE=false;\r\n\r\nexport default class Pathfind extends React.Component{\r\n    constructor(){\r\n        super();\r\n        this.state = {\r\n            grid : []\r\n        };\r\n    }\r\n\r\n    componentDidMount(){\r\n        const grid = getInitialGrid();\r\n        this.setState({grid});\r\n    }\r\n\r\n    handleMouseDown(row, col) {\r\n        if(this.state.grid[row][col].isStart===true||this.state.grid[row][col].isFinish===true){\r\n            const newGrid = getNewGrid(this.state.grid, row, col);\r\n            this.setState({grid: newGrid, mouseIsPressed: true});\r\n        }\r\n        else{\r\n            WALL_TOGGLE=true;\r\n            const newGrid = getGridWall(this.state.grid,row,col);\r\n            this.setState({grid:newGrid,mouseIsPressed: true});\r\n        }\r\n    }\r\n    handleMouseEnter(row,col){\r\n        if(WALL_TOGGLE===true){\r\n            const newGrid = getGridWall(this.state.grid,row,col);\r\n            this.setState({grid:newGrid,mouseIsPressed: true});\r\n        }\r\n    }\r\n\r\n    handleMouseUp(row,col) {\r\n        WALL_TOGGLE=false;\r\n        const newGrid =getNewEnd(this.state.grid,row,col);\r\n        this.setState({grid: newGrid, mouseIsPressed: false});\r\n      }\r\n\r\n\r\n    animateDijkstra(visitedNodesInOrder,nodesInShortestPathOrder){\r\n        for(let i=0; i<=visitedNodesInOrder.length;i++){\r\n            if(i===visitedNodesInOrder.length){\r\n                setTimeout(() => {\r\n                    this.animateShortestPath(nodesInShortestPathOrder);\r\n                }, 10*i);\r\n                return;\r\n            }\r\n            setTimeout(() => {\r\n                const node = visitedNodesInOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className=\r\n                'node node-visited';\r\n            }, 10*i);\r\n        }\r\n    }\r\n    animateShortestPath(nodesInShortestPathOrder){\r\n        for(let i=0;i < nodesInShortestPathOrder.length;i++){\r\n            setTimeout(() => {\r\n                const node = nodesInShortestPathOrder[i];\r\n                document.getElementById(`node-${node.row}-${node.col}`).className =\r\n                'node node-shortest-path';\r\n            }, 50 * i);\r\n        }\r\n    }\r\n\r\n    visualizeDijkstra(){\r\n        const {grid}= this.state;\r\n        const startNode = grid[START_ROW][START_COL];\r\n        const endNode = grid[END_ROW][END_COL];\r\n        const visitedNodesInOrder = dijkstra(grid,startNode,endNode);\r\n        const nodesInShortestPathOrder = getNodesInShortestPathOrder(endNode);\r\n        this.animateDijkstra(visitedNodesInOrder,nodesInShortestPathOrder);\r\n    }\r\n    render(){\r\n        const {grid, mouseIsPressed}= this.state;\r\n        return(\r\n            <div>\r\n                <button class='button' onClick={()=>this.visualizeDijkstra()}>\r\n                    Visualize Shortest Path Using Dijkstra\r\n                    </button>\r\n                <div className ='grid'>\r\n                    {grid.map((row,rowIdx)=>{\r\n                        return (\r\n                            <div key={rowIdx}>\r\n                                {row.map((node,nodeIdx)=>{\r\n                                    const {row,col,isStart,isFinish,isWall} = node;\r\n                                    return(\r\n                                        <Node \r\n                                        key={nodeIdx} \r\n                                        col={col} \r\n                                        row={row}\r\n                                        isFinish= {isFinish}\r\n                                        isStart={isStart}\r\n                                        isWall={isWall}\r\n                                        mouseIsPressed={mouseIsPressed}\r\n                                        onMouseDown={(row,col)=>\r\n                                        this.handleMouseDown(row,col)}\r\n                                        onMouseEnter={(row,col)=>this.handleMouseEnter(row,col)}\r\n                                        onMouseUp={(row,col) => this.handleMouseUp(row,col)}\r\n                                        \r\n                                        />\r\n                                    );\r\n                                })}\r\n                            </div>\r\n                        );\r\n                    \r\n    })}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n        \r\n}\r\nconst getInitialGrid= ()=>{\r\n    const grid = [];\r\n    for(let row =0;row <window.screen.height/56 ;row++){\r\n        const currentRow=[];\r\n        for(let col =0; col<window.screen.width/40;col++){\r\n            currentRow.push(createNode(col,row));\r\n        }\r\n        grid.push(currentRow);\r\n    }\r\n    return grid;\r\n}\r\n\r\nconst createNode= (col,row) => {\r\n    return{\r\n        col,\r\n        row,\r\n        isStart: col=== START_COL && row===START_ROW,\r\n        isFinish: col===END_COL && row === END_ROW,\r\n        isVisited: false,\r\n        distance: Infinity,\r\n        previousNode: null,\r\n        isWall: false,\r\n    };\r\n}\r\n\r\nconst getNewGrid = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    \r\n    if(node.isStart===true){\r\n        START_COL=-1;\r\n        START_ROW = -1;\r\n        const newNode = {\r\n        ...node,\r\n        isStart: false,\r\n        };\r\n        newGrid[row][col] = newNode;\r\n    }\r\n    if(node.isFinish===true){\r\n        END_COL=-1;\r\n        END_ROW  = -1;\r\n        const newNodeS = {\r\n            ...node,\r\n            isFinish: false,\r\n            };\r\n        newGrid[row][col] = newNodeS;\r\n    }\r\n    return newGrid;\r\n  };\r\n\r\nconst getGridWall=(grid,row,col)=>{\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    if((row!==START_ROW && col !==START_COL)|| (row!==END_ROW && col!==END_COL)){\r\n        const newNode ={\r\n            ...node,\r\n            isWall:true,\r\n        };\r\n        newGrid[row][col]= newNode;\r\n    }\r\n    return newGrid;\r\n};\r\n\r\nconst getNewEnd = (grid, row, col) => {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    if(END_COL===-1){\r\n        END_COL =col;\r\n        END_ROW = row;\r\n        const newNodeS = {\r\n            ...node,\r\n            isFinish: true,\r\n            };\r\n        newGrid[row][col] = newNodeS;\r\n    }\r\n    if(START_ROW===-1){\r\n        START_COL = col;\r\n        START_ROW =row;\r\n        const newNode = {\r\n            ...node,\r\n            isStart: true,\r\n            };\r\n            newGrid[row][col] = newNode;\r\n    }\r\n    return newGrid;\r\n  };","import logo from \"./logo.svg\";\nimport \"./App.css\";\nimport Pathfind from \"./files/Pathfind\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Pathfind />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}